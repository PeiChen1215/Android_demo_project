超市管理系统 实施总结
日期: 2025-12-22

1. Database Schema Updates (Version 5)
   - Added `warehouse_stock` (INTEGER) to `products` table.
   - Added `min_warehouse_stock` (INTEGER) to `products` table.
   - Added `production_date` (INTEGER/Long) to `products` table.
   - Added `expiration_date` (INTEGER/Long) to `products` table.
   - Updated `DatabaseHelper.onUpgrade` to handle migrations from v3 -> v4 -> v5.

2. Model Updates (Product.java)
   - Added fields: `warehouseStock`, `minWarehouseStock`, `productionDate`, `expirationDate`.
   - Updated `fromCursor` and `toContentValues` to handle new fields.
   - Added getters and setters.

3. Data Access Object (DAO) Updates
   - ProductDAO:
     - Updated `addProduct` and `updateProduct` to persist new fields.
     - Updated `getAllColumns` to include new columns in queries.
     - Added `getLowWarehouseStockProducts()` to find items needing purchase.
     - Updated `getLowStockProducts()` to clarify it checks shelf stock.
   - SaleDAO:
     - Updated `addSale` to perform REAL-TIME deduction of shelf stock (`stock` column) within a transaction.
   - InventoryDAO:
     - Added `restockShelf(productId, qty)`: Transactional move from Warehouse -> Shelf.
     - Added `receivePurchase(productId, qty)`: Increases Warehouse stock.

4. Business Logic Implementation
   - "Front Store, Back Warehouse" model implemented.
   - Real-time inventory tracking for shelf items.
   - Separation of "Restock" (Internal) and "Purchase" (External) workflows.
   - Foundation for Expiry tracking (fields added).

5. Next Steps (UI & Features)
   - Update `ProductAddActivity` to input new fields.
   - Update `ProductDetailActivity` to display new fields.
   - Create `RestockActivity` for Stock Managers (list low shelf stock -> move from warehouse).  (IMPLEMENTED)
   - Create `PurchaseActivity` for Buyers (list low warehouse stock -> add purchase order).  (BASIC UI IMPLEMENTED: supports simple receive-and-increase-warehouse flow)
   - Implement Role-Based Visibility in `MainActivity` (hide buttons based on user role).

Current Status:
- Backend logic is COMPLETE and SAFE.
- Database is consistent.
- Models are aligned.
- Ready for UI updates.

Recent Frontend Work (2025-12-22):
 - Implemented `RestockActivity` (UI + dialog) at `app/src/main/java/com/example/android_development/activities/RestockActivity.java` and layout `activity_restock.xml` + `dialog_restock.xml`. Uses `ProductDAO.getLowStockProducts()` and `InventoryDAO.restockShelf()` to perform transactional internal restock.
 - Implemented `PurchaseActivity` (basic UI) at `app/src/main/java/com/example/android_development/activities/PurchaseActivity.java` and layout `activity_purchase.xml`. Lists low-warehouse products and allows entering received quantity to call `InventoryDAO.receivePurchase()` (simple receive flow; does not yet create persistent `purchase_orders` records).
 - Registered both activities in `AndroidManifest.xml`.

Recently added full PO support (models + DAO + simple UI):
 - Added `PurchaseLine` model at `app/src/main/java/com/example/android_development/model/PurchaseLine.java`.
 - Added `PurchaseDAO` at `app/src/main/java/com/example/android_development/database/PurchaseDAO.java` with methods to create PO, add PO lines, query pending POs, and `receiveAndMatchPo()` which transactionally calls `InventoryDAO.receivePurchase()` for each line and marks the PO as `received`.
 - Added `PurchaseCreateActivity` (`app/src/main/java/com/example/android_development/activities/PurchaseCreateActivity.java`) and layout `res/layout/activity_purchase_create.xml` to create simple POs from low-warehouse stock.
 - Added `PurchaseListActivity` (`app/src/main/java/com/example/android_development/activities/PurchaseListActivity.java`) and layout `res/layout/activity_purchase_list.xml` to list pending POs and perform receive/match by tapping an item.
 - Registered the new activities in `AndroidManifest.xml`.
 - Extended PO support (editable UI & workflow):
    - Added `SupplierDAO` (`app/src/main/java/com/example/android_development/database/SupplierDAO.java`) to list suppliers.
    - Extended `PurchaseDAO` with `updatePurchaseLine`, `deletePurchaseLine`, `updatePurchaseOrder` for full editing support.
    - Added `PoLineAdapter` (`app/src/main/java/com/example/android_development/activities/adapter/PoLineAdapter.java`) and item layout `res/layout/item_po_line.xml` to edit PO lines (qty, remove).
    - Added `PurchaseDetailActivity` (`app/src/main/java/com/example/android_development/activities/PurchaseDetailActivity.java`) and layout `res/layout/activity_purchase_detail.xml` for PO detail, supplier selection, approve, save and receive/match.
    - `PurchaseCreateActivity` now opens `PurchaseDetailActivity` after creating a PO so user can edit lines and complete workflow.

Notes:
 - `PurchaseActivity` currently implements a simplified "采购入库（接收）" flow. Full purchase order lifecycle (创建 PO、审批、到货匹配) is a next-step feature.
 - Restock flow validates warehouse quantity server-side via `InventoryDAO.restockShelf()`;前端已弹窗输入数量并显示成功/失败提示。

Hotfix (2025-12-22):
 - 修复数据库升级兜底逻辑：增强了 `DatabaseHelper.onUpgrade`，在升级完成后尝试创建采购/盘点/销售等脚手架表（`suppliers`、`purchase_orders`、`purchase_lines`、`stock_counts`、`stock_count_lines`、`sales`、`sale_lines`），以避免旧数据库缺少这些表导致在打开 `StockCountActivity` 或创建盘点记录时崩溃。
 - 原因说明：若用户先前安装的数据库版本没有盘点表，UI 调用 `inventoryDAO.createStockCount()` 会触发表不存在的 SQLiteException 并导致崩溃；现在升级中将尝试创建缺失表，避免此类错误。

Status Notes:
 - 已检查 `activity_stock_count.xml` 与 `StockCountActivity` 中使用的 ID 匹配。
 - 已核对 `activity_stock_count.xml` 与 `StockCountActivity` 中使用的控件 ID 是否匹配。
 - 若用户从旧版升级，请启动应用以触发 `onUpgrade`；若仍崩溃，请收集 Logcat 的 SQLiteException 日志并提交。


---

最近的代码修复与前端显示改进

以下为本次我对代码库做的修复与前端显示改进，解决“收货后看不到库存变化 / 前端库存表述混淆”等问题：

1) 修复 `InventoryDAO.receivePurchase` 的实现
   - 原实现使用 `execSQL` 静默执行 UPDATE，若 `product_id` 不存在或表结构异常时不会返回失败，导致用户界面显示“已收货”但实际未更新库存。
   - 我将 `receivePurchase` 改为先查询当前 `warehouse_stock`，计算新的值后使用 `db.update(...)` 写回，并根据受影响行数返回 true/false。这样能正确在 `PurchaseDAO.receiveAndMatchPo` 的事务里判定成功/失败并回滚。

2) 加强 `PurchaseDetailActivity` 的事务与权限控制
   - 将 `PurchaseDetailActivity` 从 `Activity` 统一改为继承 `AppCompatActivity`（保持样式一致性）。
   - 使用 `PrefsManager` 读取当前用户角色（`role`），按照常用角色名（如 `系统管理员`、`采购员`、`库存管理员`、`售货员` 等）启/禁用 `保存`、`批准`、`入库` 按钮，初步实现前端角色权限限制。
   - 把保存采购单（增删改 PO 行）、批准 PO、接收入库等关键写操作包裹在 SQLite 事务中，增加错误日志记录，避免部分更新导致数据不一致。

3) 实现 `PurchaseListActivity` 列表项点击跳转
   - 实现列表适配器的 item 点击回调，点击采购单条目会通过 Intent 打开 `PurchaseDetailActivity` 并传递 `po_id`，用户可以进入详情并完成批准/入库等后续操作。

4) 在商品列表中同时显示“货架库存”与“仓库库存”以减少歧义
   - 在 `res/layout/item_product.xml` 的列表项中新增一个用于显示仓库库存的 `TextView`（`textViewProductWarehouseStock`）。
   - 更新 `ProductAdapter` 绑定逻辑：将原来显示的“库存”标签改为更明确的“货架: <数值>”，并在列表项同时显示“仓库: <数值>”。同时把仓库库存纳入 Diff 比较，保证列表更新的准确性。

5) 其它建议与注意事项
   - 当前收货流程把货放入 **仓库（warehouse_stock）**，而前端销售和大多数商品展示关注的是 **货架（stock）**。这两者是不同概念：收货成功后若要立刻对顾客可售，应执行补货（restock）或在收货时同时上架（视业务决定）。
   - 我建议在关键库存变更位置统一记录库存事务（调用 `ProductDAO.adjustStockWithTransaction` 或 `addStockTransaction`），以便审计与误操作回溯。
   - 如果需要我继续，我可以：
     A) 在收货时同时将部分或全部数量直接上架（仓库 -> 货架），并记录库存事务；或
     B) 在 UI 中统一展示并注释“货架库存 / 仓库库存”的含义（已初步改为显示两者）；或
   C) 在更多写操作处（如结账）统一加入事务与角色校验。

接下来要做（短期 / 中期 / 长期任务）

短期（优先级高，1-2 周）
- 将缺失或实现不完整的 Activity 补全并解耦 UI 与业务逻辑：
   - `ProductDetailActivity`：确保同时显示并注释“货架库存 / 仓库库存”，并提供“管理库存（入库/出库/补货）”的清晰入口；
   - `RestockActivity`：确认内部补货流程与权限检查（仅库存管理员可执行），并把与 DB 的直接调用封装到 `InventoryService`；
   - `PurchaseActivity` / `PurchaseCreateActivity` / `PurchaseDetailActivity`：补全完整 PO 生命周期（创建 → 编辑 → 批准 → 接收入库），并在 UI 中区分“简化入库”与“基于 PO 的入库”。
- 在关键写操作处统一调用后端服务/仓库（Repository）接口（如 `ProductRepository`、`InventoryService`、`PurchaseService`），把直接的 DB 操作从 Activity 中剥离出来，便于测试与重用。

中期（2-6 周）
- 后端模块化重构：
   - 建立 `service` 或 `usecase` 层（例如 `InventoryService`, `PurchaseService`, `SaleService`），所有 Activity 通过这些服务调用业务逻辑；DAO 仍只负责原子数据库操作。
   - 为关键业务流程编写单元测试（使用 Robolectric / 本地单元测试针对 DAO 与 Service 层）。
- 权限与审计：
   - 在写操作中统一记录 `StockTransaction`，并保证所有库存变更都有对应的事务日志；
   - 在 UI 与服务层增加基于角色的权限校验（不仅仅是按钮禁用，服务层也应校验）。

长期（>6 周 / 可选）
- 自动化盘点与采购优化：
   - 使用 `WorkManager` 实现每天定时盘点或批量任务（如夜间汇总当日销售并生成采购建议）；
   - 引入简单的采购计划算法（考虑过期率、日均销量、季节性系数），生成采购建议草稿供采购员审核；
- 架构与扩展：
   - 若将来需要多客户端/服务器同步，建议把核心业务逻辑迁移到一个轻量后端（REST 或 GraphQL），移动设备仅作为客户端。当前本地 DB 模式应设计好同步锚点与冲突解决策略。

下一步计划（我可以立即执行的工作）
1) 在代码库新增 `service` 包并实现 `InventoryService` 与 `PurchaseService` 的基础封装，封装现有 DAO 调用（我会先在 `app/src/main/java/com/example/android_development/service/` 创建文件）；
2) 将 `PurchaseDetailActivity` 与 `RestockActivity` 的 DB 调用替换为对服务的调用，保持行为与现有逻辑一致但解耦 UI；
3) 为 `InventoryService.receivePurchase` 与 `restockShelf` 添加基础单元测试（本地 JVM 测试）以保证关键路径稳定；
4) 提交变更为一个 Git commit（我会先生成 commit message，并等待你确认后执行 `git push`）。

